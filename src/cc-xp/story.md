---
description: XP story – ユーザーストーリーを詳細化（対話重視）
argument-hint: '[id] ※省略時は最初の selected を使用'
allowed-tools: Bash(date), Bash(echo), Bash(git:*), Bash(test), Bash(grep), ReadFile, WriteFile
---

## ゴール

ストーリーを**ユーザーとの対話**として詳細化し、明確な受け入れ条件を定義する。

## XP原則

- **コミュニケーション**: ストーリーはユーザーとの約束
- **フィードバック**: 受け入れ条件で期待を明確化
- **勇気**: 不明点があれば仮定を置いて進む
- **継続的インテグレーション**: 各ステップをコミット

## 現在の状態確認

### 環境チェック
- backlog存在確認: !test -f docs/cc-xp/backlog.yaml
- Git状態: !git status --short
- 現在のブランチ: !git branch --show-current
- 現在時刻: !date +"%Y-%m-%dT%H:%M:%S%:z"

### 対象ストーリーの特定

$ARGUMENTS が指定されている場合はそのID、なければ最初の `selected` ステータスのストーリーを使用してください。

@docs/cc-xp/backlog.yaml から該当ストーリーの**全情報**を取得：

#### 基本情報
- ID, タイトル, サイズ, 価値, 現在のステータス

#### 戦略的情報（plan.mdで生成）
- **business_value**: 事業価値スコア（1-10）
- **user_value**: ユーザー価値スコア（1-10） 
- **implementation_cost**: 実装コスト（1-10）
- **risk_level**: リスクレベル（1-10）
- **priority_score**: 優先順位スコア（計算値）

#### 仮説駆動項目（必須）
- **hypothesis**: 検証すべき仮説
- **kpi_target**: 具体的成功指標
- **success_metrics**: 測定方法

#### 戦略コンテキスト
- **user_persona**: 対象ユーザー
- **business_context**: 事業上の位置づけ
- **competition_analysis**: 競合との差別化要因

**ステータスバリデーション**：
- 対象ストーリーが `selected` であることを確認
- すでに `in-progress` 以降のステータスの場合は、そのまま継続するか確認
- `done` ステータスのストーリーは詳細化不可

**重要**: 上記の戦略的情報が存在しない場合は、旧形式のbacklog.yamlとして扱い、基本機能のみで進行してください。

backlogが存在しない場合は、先に `/cc-xp:plan` の実行を案内してください。

### AI分析レポートの参照

**重要**: ストーリー詳細化前に、plan.mdで生成されたAI分析結果を必ず参照してください。

@docs/cc-xp/analysis_summary.md が存在する場合：
- 市場・競合分析結果を確認
- ペルソナ定義を参照  
- 収益化戦略を把握
- 差別化要因を理解

存在しない場合は、限定的なストーリー詳細化のみ実行してください。

**活用方法**:
```bash
# AI分析レポートの確認
if [ -f docs/cc-xp/analysis_summary.md ]; then
  echo "✅ AI分析レポート参照可能"
  echo "📊 ビジネス戦略を考慮したストーリー詳細化を実行"
else
  echo "⚠️ AI分析レポートなし - 基本的なストーリー詳細化のみ実行"
fi
```

## フィーチャーブランチの作成

### ブランチの確認
- 既存ブランチ一覧: !git branch -a

`story-[ID]` ブランチが既に存在する場合は、チェックアウトするか確認してください：
```
ブランチ story-[ID] が既に存在します。
チェックアウトしますか？ (y/N): 
```

存在しない場合は新規作成：
```bash
git checkout -b story-[ID]
```

## 戦略的ストーリー詳細化

### 1. 仮説駆動ユーザーストーリーの作成

選択されたストーリー「[タイトル]」を**AI分析結果と戦略情報を統合**して詳細化してください：

#### 🎯 核心仮説の確認と詳細化

**重要**: backlog.yamlの項目がEvidence-Driven TDD要求レベルに達していない場合、以下に従って**詳細化**してください：

##### hypothesis の詳細化
backlog.yamlから取得した仮説が抽象的な場合、以下フォーマットで具体化：
```
「[具体的実装]が[測定可能条件]を達成することで、[対象ユーザー]の[測定可能価値指標]が[数値]以上[向上/達成]する」
```

**詳細化例**:
- 抽象的 ❌: "正確なテトロミノ実装がゲーム体験の基盤となる"
- 具体化 ✅: "テトロミノ生成処理が100ms以内に完了し、形状精度100%を達成することで、プレイヤーの操作満足度が95%以上向上する"

##### kpi_target の詳細化
数値基準を含む測定可能な目標に変換：
```
「[パフォーマンス指標]<[数値][単位]、[品質指標][数値]%、[完全性指標][数値]%、[追加指標]」
```

**詳細化例**:
- 曖昧 ❌: "7種類のテトロミノが仕様通りに表示される"
- 具体化 ✅: "テトロミノ生成時間<100ms、形状精度100%、色彩判別率99%、7種類完全実装率100%"

##### success_metrics の詳細化
自動テスト可能な具体的測定項目にリスト化：
```
「1.[測定項目1]、2.[測定項目2]、3.[パフォーマンステスト]、4.[品質テスト]」
```

**詳細化例**:
- 曖昧 ❌: "視覚テスト、形状検証、色彩確認"
- 具体化 ✅: "1.各テトロミノ4×4マトリクス形状一致テスト、2.RGB色値精度テスト、3.生成時間パフォーマンステスト、4.ランダム生成統計テスト"

#### 👤 戦略的ペルソナの活用
以下を統合してペルソナを定義：
- backlog.yamlの`user_persona`
- analysis_summary.mdのペルソナ分析
- 競合分析結果(`competition_analysis`)

#### 📝 拡張ユーザーストーリー形式
```
As a [戦略的ペルソナ]
I want [機能・要望]
So that [得られる価値]
And I expect [具体的な成功指標/KPI]
```

**従来例**：
- As a **プレイヤー**
- I want **ブラウザでテトリスを開く**
- So that **すぐに遊び始められる**

**改善例**（仮説駆動）：
- As a **忙しいビジネスパーソン（25-35歳、通勤中の短時間娯楽を求める）**
- I want **1クリックで即座にテトリスを開始**
- So that **移動中の5-10分を有効活用してストレス解消できる**
- And I expect **初回起動から3秒以内でゲーム開始、セッション時間平均7分**

### 2. 仮説検証重視の受け入れ条件定義

**仮説を検証できる**条件を**3つ以内**で作成してください。各条件は必ずKPI測定可能な形式にします：

#### 🎯 測定可能な受け入れ条件の強制要件

**全受け入れ条件は以下を満たす必要があります**：
1. **Given条件**: 実装で設定可能な前提状態
2. **When操作**: コード実行で再現可能な具体的動作
3. **Then期待結果**: 自動テストで検証可能な測定可能な結果
4. **And追加条件**: KPI測定・ログ記録・証拠収集を含む

#### Evidence-Driven受け入れ条件フォーマット

**必須フォーマット**：
```gherkin
シナリオ[N]: [仮説検証内容]（[検証層]）
Given [実装で設定可能な具体的前提条件]
When [コードで実行可能な具体的操作]
Then [測定可能な数値結果] AND [自動テストで検証可能な状態]
And [KPI測定データが記録される] AND [証拠データが保存される]
```

#### 🎯 仮説検証の3層構造（改訂）

**第1層：核心仮説検証**（必須 ★）
- `hypothesis`の具体的数値条件を直接測定する条件
- `kpi_target`の各数値基準をすべて満たす条件
- パフォーマンス・品質・完全性の実測値による検証

**第2層：ユーザー体験検証**（重要）  
- `user_persona`の具体的行動パターンを再現する条件
- 競合優位性を数値で実証する条件（`competition_analysis`活用）
- エンゲージメント指標を測定・記録する条件

**第3層：技術品質検証**（必要に応じて）
- エラー処理・境界値テスト等の堅牢性条件
- スケーラビリティ・保守性等の実測可能な品質条件

#### 💡 改善前後の比較例

**従来の受け入れ条件**（develop Phase 0で停止）：
```gherkin
シナリオ1: テトリス盤面表示
Given ブラウザでページを開く
When テトリスゲームを起動
Then 10x20の盤面が表示される
```

**Evidence-Driven受け入れ条件**（develop Phase 0をクリア）：
```gherkin  
シナリオ1: 100ms以内テトロミノ生成と形状精度100%達成（核心仮説検証）
Given テトロミノ生成システムが初期化された状態で
When テトロミノ生成処理が実行される時
Then 生成時間が100ms以内に完了する AND 形状精度が100%を達成する
And KPI測定データ（生成時間、形状精度、色彩判別率）が記録される
And 証拠データがテストログに保存される

シナリオ2: プレイヤー操作満足度95%向上の実証（ユーザー体験検証）
Given 対象ペルソナ（忙しいビジネスパーソン）のテストケースで
When 実際のゲーム操作セッション（5-10分間）を実行する時  
Then 操作レスポンス遅延が50ms以下を維持する AND UI応答性が95%以上を記録する
And プレイヤー満足度指標が95%以上向上する AND セッション継続率が計測される

シナリオ3: 7種類完全実装率100%と色彩判別率99%達成（技術品質検証）
Given すべてのテトロミノタイプ（I,O,T,S,Z,J,L）の生成テストで
When ランダム生成処理を1000回実行する時
Then 7種類すべてが仕様通り生成される AND 色彩判別率が99%以上を達成する  
And 統計データが自動収集される AND 品質メトリクスが証拠として保存される
```

#### 📊 KPI測定可能性チェック

各受け入れ条件について、以下を確認してください：
- [ ] 定量的な測定が可能
- [ ] backlog.yamlの`kpi_target`に対応
- [ ] `success_metrics`で測定手法が明確
- [ ] 仮説検証に直結している

### 3. テスト戦略の判定

各受け入れ条件について、以下を判断してください：

#### 基本テスト戦略
- **automated**: プログラムで検証可能（ユニットテストのみ）
- **manual**: 人の目で確認が必要
- **hybrid**: 両方必要

#### E2Eテスト戦略（Webアプリケーション限定）
- **e2e-required**: E2Eテスト必須（UI操作の核心機能）
- **e2e-optional**: E2Eテスト推奨（品質向上のため）
- **unit-only**: ユニットテストのみで十分（ロジック中心）

#### 判定基準

**E2Eテストが必須（e2e-required）**：
- ユーザーの主要なワークフロー（ログイン、購入、投稿など）
- フォーム送信とバリデーション
- ナビゲーションとページ遷移
- 外部APIとの統合部分

**E2Eテストが推奨（e2e-optional）**：
- 補助的なUI機能
- アニメーションや視覚効果
- レスポンシブデザインの確認

**ユニットテストのみ（unit-only）**：
- 純粋な計算ロジック
- データ変換処理
- バリデーション関数

### 4. 実装ヒントの追加

技術的な観点から実装のヒントを簡潔に追加：
- 推奨ライブラリ/フレームワーク
- 注意すべきポイント
- 参考リンク（あれば）

## 拡張ストーリーファイルの作成

`docs/cc-xp/stories/[ID].md` を**戦略的情報を統合**した以下の内容で作成してください：

### Evidence-Driven品質チェック（生成後必須実行）

**ストーリーファイル作成後、以下を必ず確認**：
1. ✅ hypothesis に具体的数値・測定条件が含まれている
2. ✅ kpi_target に複数の数値基準が設定されている
3. ✅ success_metrics に4つ以上の具体的測定項目がリストされている
4. ✅ 各受け入れ条件が実装・測定可能で具体的である

**品質チェック失敗時は、該当項目を上記詳細化指示に従って修正**

```markdown
---
# 基本情報
created_at: [現在時刻]
estimated_time: [推定分数]
test_strategy: [automated/manual/hybrid]
e2e_strategy: [e2e-required/e2e-optional/unit-only] # Webアプリの場合のみ
difficulty: [easy/medium/hard]

# 仮説駆動項目（詳細化済み）
hypothesis: "上記詳細化指示で具体化された検証可能な仮説"
kpi_target: "複数数値基準を含む測定可能な目標"
success_metrics: "自動テスト可能な具体的測定項目リスト"
business_value: [1-10]
user_value: [1-10]
priority_score: [計算値]

# 戦略コンテキスト
user_persona: "[対象ユーザー]"
business_context: "[事業上の位置づけ]"
competition_analysis: "[競合差別化要因]"
---

# Story: [タイトル]

## 核心仮説
**仮説**: [hypothesis]
**成功指標**: [kpi_target]  
**測定方法**: [success_metrics]

## 戦略的ユーザーストーリー
As a [戦略的ペルソナ]
I want [機能・要望]
So that [得られる価値]
And I expect [具体的KPI/成功指標]

## 仮説検証重視の受け入れ条件

### シナリオ1: [核心仮説検証]
Given [戦略的前提条件]
When [アクション]
Then [KPI測定可能な結果]

### シナリオ2: [ユーザー体験検証]
Given [ユーザーコンテキスト]  
When [ユーザー操作]
Then [競合優位性を示す結果]

## テスト戦略（仮説検証重視）
- **仮説検証テスト**: [KPI測定を含むテスト]
- **自動テスト**: [機能検証]
- **手動確認**: [ユーザー体験検証]
- **E2E戦略**: [e2e-required/e2e-optional/unit-only]

## ビジネス価値実現のヒント
- **競合差別化**: [competition_analysisに基づく実装方針]
- **ユーザー価値最大化**: [user_personaに基づく配慮点]
- **KPI測定**: [success_metricsの実装方法]

## 前提条件
- [環境要件]
- [依存関係]  
- **KPI測定環境**: [測定ツール・システム要件]
```

## backlog.yamlの更新

@docs/cc-xp/backlog.yaml の該当ストーリーを更新：
- status: `selected` → `in-progress` （**重要**: doneにはしない）
- updated_at: 現在時刻

**ステータスの流れ**：
- `selected` (plan) → `in-progress` (story) → `testing` (develop) → `done` (review accept のみ)

## 変更のコミット

以下でコミットしてください：

```bash
git add docs/cc-xp/stories/[ID].md docs/cc-xp/backlog.yaml
git commit -m "docs: ストーリー詳細化 - [タイトル]"
```

## 戦略的完了サマリーの表示

**必ず以下の拡張サマリーを表示してください**：

```
🎯 戦略的ストーリー詳細化完了
============================

ストーリー: [タイトル]
ブランチ: story-[ID]
ステータス: in-progress ✅

📊 ビジネス指標:
- 事業価値: [business_value]/10
- ユーザー価値: [user_value]/10
- 優先度スコア: [priority_score]
- サイズ: [ポイント]
- 総合価値: [High/Medium/Low]

🎲 核心仮説:
仮説: "[hypothesis]"
成功指標: "[kpi_target]"
測定方法: "[success_metrics]"

👤 対象ユーザー:
ペルソナ: "[user_persona]"

🎯 仮説検証重視の受け入れ条件:
✓ [シナリオ1: 核心仮説検証要約]
✓ [シナリオ2: ユーザー体験検証要約]  
✓ [シナリオ3: 技術品質検証要約]（あれば）

🔬 テスト戦略:
- 仮説検証: [KPI測定含む]
- 自動テスト: [automated/manual/hybrid] 
- E2E戦略: [e2e-required/e2e-optional/unit-only]

⏱️ 推定: [X]分
🚀 期待効果: [ビジネス成果予測]
```

### 重要：次のコマンドを必ず表示

```
🚀 次のステップ
================
TDDサイクルを開始:
→ /cc-xp:develop

このコマンドで:
• Red: 失敗するテストを作成
• Green: 最小限の実装
• Refactor: コード改善

💡 TDDのコツ
-----------
• 最初のテストは最も簡単なものから
• 一度に一つずつ進める
• コミットを細かく分ける
```

## 注意事項

- 受け入れ条件は具体的で測定可能に
- YAGNIを意識し、過度な詳細化を避ける
- ユーザー価値を中心に考える
